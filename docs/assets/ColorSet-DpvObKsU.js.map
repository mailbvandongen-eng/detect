{"version":3,"file":"ColorSet-DpvObKsU.js","sources":["../../node_modules/@amcharts/amcharts5/.internal/core/util/ColorSet.js"],"sourcesContent":["import { Entity } from \"./Entity\";\r\nimport { Color } from \"./Color\";\r\n/**\r\n * An object which holds list of colors and can generate new ones.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Color_sets} for more info\r\n */\r\nexport class ColorSet extends Entity {\r\n    //protected _currentPass: number = 0;\r\n    _afterNew() {\r\n        // Applying themes because color set will not have parent\r\n        super._afterNewApplyThemes();\r\n        this._dirty[\"colors\"] = false;\r\n    }\r\n    _beforeChanged() {\r\n        if (this.isDirty(\"colors\")) {\r\n            this.reset();\r\n        }\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    generateColors() {\r\n        this.setPrivate(\"currentPass\", this.getPrivate(\"currentPass\", 0) + 1);\r\n        const pass = this.getPrivate(\"currentPass\");\r\n        const colors = this.get(\"colors\", [this.get(\"baseColor\", Color.fromHex(0xff0000))]);\r\n        if (!this.getPrivate(\"numColors\")) {\r\n            this.setPrivate(\"numColors\", colors.length);\r\n        }\r\n        //const len = colors.length;\r\n        const len = this.getPrivate(\"numColors\");\r\n        //const start = len - this.getPrivate(\"numColors\")!;\r\n        const start = 0;\r\n        const passOptions = this.get(\"passOptions\");\r\n        const reuse = this.get(\"reuse\");\r\n        for (let i = start; i < len; i++) {\r\n            if (reuse) {\r\n                colors.push(colors[i]);\r\n            }\r\n            else {\r\n                const hsl = colors[i].toHSL();\r\n                let h = hsl.h + (passOptions.hue || 0) * pass;\r\n                while (h > 1)\r\n                    h -= 1;\r\n                let s = hsl.s + (passOptions.saturation || 0) * pass;\r\n                //if (s > 1) s -= Math.floor(s);\r\n                if (s > 1)\r\n                    s = 1;\r\n                if (s < 0)\r\n                    s = 0;\r\n                let l = hsl.l + (passOptions.lightness || 0) * pass;\r\n                //if (l > 1) l -= Math.floor(l);\r\n                while (l > 1)\r\n                    l -= 1;\r\n                colors.push(Color.fromHSL(h, s, l));\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Returns a [[Color]] at specific index.\r\n     *\r\n     * If there's no color at this index, a new color is generated.\r\n     *\r\n     * @param   index  Index\r\n     * @return         Color\r\n     */\r\n    getIndex(index) {\r\n        const colors = this.get(\"colors\", []);\r\n        const saturation = this.get(\"saturation\");\r\n        if (index >= colors.length) {\r\n            this.generateColors();\r\n            return this.getIndex(index);\r\n        }\r\n        return saturation != null ? Color.saturate(colors[index], saturation) : colors[index];\r\n    }\r\n    /**\r\n     * Returns next [[Color]] in the list.\r\n     *\r\n     * If the list is out of colors, new ones are generated dynamically.\r\n     */\r\n    next() {\r\n        let currentStep = this.getPrivate(\"currentStep\", this.get(\"startIndex\", 0));\r\n        this.setPrivate(\"currentStep\", currentStep + this.get(\"step\", 1));\r\n        return this.getIndex(currentStep);\r\n    }\r\n    /**\r\n     * Resets counter to the start of the list, so the next call for `next()` will\r\n     * return the first color.\r\n     */\r\n    reset() {\r\n        this.setPrivate(\"currentStep\", this.get(\"startIndex\", 0));\r\n        this.setPrivate(\"currentPass\", 0);\r\n    }\r\n}\r\nObject.defineProperty(ColorSet, \"className\", {\r\n    enumerable: true,\r\n    configurable: true,\r\n    writable: true,\r\n    value: \"ColorSet\"\r\n});\r\nObject.defineProperty(ColorSet, \"classNames\", {\r\n    enumerable: true,\r\n    configurable: true,\r\n    writable: true,\r\n    value: Entity.classNames.concat([ColorSet.className])\r\n});\r\n//# sourceMappingURL=ColorSet.js.map"],"names":["ColorSet","Entity","pass","colors","Color","len","start","passOptions","reuse","hsl","h","index","saturation","currentStep"],"mappings":"+CAOO,MAAMA,UAAiBC,CAAO,CAEjC,WAAY,CAER,MAAM,qBAAoB,EAC1B,KAAK,OAAO,OAAY,EAC5B,CACA,gBAAiB,CACT,KAAK,QAAQ,QAAQ,GACrB,KAAK,MAAK,CAElB,CAIA,gBAAiB,CACb,KAAK,WAAW,cAAe,KAAK,WAAW,cAAe,CAAC,EAAI,CAAC,EACpE,MAAMC,EAAO,KAAK,WAAW,aAAa,EACpCC,EAAS,KAAK,IAAI,SAAU,CAAC,KAAK,IAAI,YAAaC,EAAM,QAAQ,QAAQ,CAAC,CAAC,CAAC,EAC7E,KAAK,WAAW,WAAW,GAC5B,KAAK,WAAW,YAAaD,EAAO,MAAM,EAG9C,MAAME,EAAM,KAAK,WAAW,WAAW,EAEjCC,EAAQ,EACRC,EAAc,KAAK,IAAI,aAAa,EACpCC,EAAQ,KAAK,IAAI,OAAO,EAC9B,QAAS,EAAIF,EAAO,EAAID,EAAK,IACzB,GAAIG,EACAL,EAAO,KAAKA,EAAO,CAAC,CAAC,MAEpB,CACD,MAAMM,EAAMN,EAAO,CAAC,EAAE,MAAK,EAC3B,IAAIO,EAAID,EAAI,GAAKF,EAAY,KAAO,GAAKL,EACzC,KAAOQ,EAAI,GACPA,GAAK,EACT,IAAI,EAAID,EAAI,GAAKF,EAAY,YAAc,GAAKL,EAE5C,EAAI,IACJ,EAAI,GACJ,EAAI,IACJ,EAAI,GACR,IAAI,EAAIO,EAAI,GAAKF,EAAY,WAAa,GAAKL,EAE/C,KAAO,EAAI,GACP,GAAK,EACTC,EAAO,KAAKC,EAAM,QAAQM,EAAG,EAAG,CAAC,CAAC,CACtC,CAER,CASA,SAASC,EAAO,CACZ,MAAMR,EAAS,KAAK,IAAI,SAAU,CAAA,CAAE,EAC9BS,EAAa,KAAK,IAAI,YAAY,EACxC,OAAID,GAASR,EAAO,QAChB,KAAK,eAAc,EACZ,KAAK,SAASQ,CAAK,GAEvBC,GAAc,KAAOR,EAAM,SAASD,EAAOQ,CAAK,EAAGC,CAAU,EAAIT,EAAOQ,CAAK,CACxF,CAMA,MAAO,CACH,IAAIE,EAAc,KAAK,WAAW,cAAe,KAAK,IAAI,aAAc,CAAC,CAAC,EAC1E,YAAK,WAAW,cAAeA,EAAc,KAAK,IAAI,OAAQ,CAAC,CAAC,EACzD,KAAK,SAASA,CAAW,CACpC,CAKA,OAAQ,CACJ,KAAK,WAAW,cAAe,KAAK,IAAI,aAAc,CAAC,CAAC,EACxD,KAAK,WAAW,cAAe,CAAC,CACpC,CACJ,CACA,OAAO,eAAeb,EAAU,YAAa,CACzC,WAAY,GACZ,aAAc,GACd,SAAU,GACV,MAAO,UACX,CAAC,EACD,OAAO,eAAeA,EAAU,aAAc,CAC1C,WAAY,GACZ,aAAc,GACd,SAAU,GACV,MAAOC,EAAO,WAAW,OAAO,CAACD,EAAS,SAAS,CAAC,CACxD,CAAC","x_google_ignoreList":[0]}