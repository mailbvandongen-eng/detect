import{ao as C,J as N,at as P,n as M,_ as m,m as A,fV as L,o as G}from"./index-D7BvpTsV.js";const R=9999999e31,F=2e-7,I={u1:[0,1],u2:[0,3],u4:[0,15],u8:[0,255],s8:[-128,127],u16:[0,65535],s16:[-32768,32767],u32:[0,4294967295],s32:[-2147483648,2147483647],f32:[-34028234663852886e22,34028234663852886e22],f64:[-Number.MAX_VALUE,Number.MAX_VALUE],unknown:void 0,c64:void 0,c128:void 0};function T(t){return I[t]??[-34028234663852886e22,34028234663852886e22]}const _={u1:1,u2:1,u4:1,u8:1,s8:1,u16:2,s16:2,u32:4,s32:4,f32:4,f64:8,unknown:4,c64:16,c128:32};function j(t){return _[t]}function W(t){return j(t.pixelType)*t.bandCount}function J(t,e){return t==null||e==null?"s32":t<0?t>=-128&&e<128?"s8":t>=-32768&&e<32768?"s16":"s32":e<256?"u8":e<65536?"u16":"u32"}function E(t){return(t?.startsWith("s")||t?.startsWith("u"))??!1}function q(t,e,l,n){let[r,i]=T(l);const s=E(l);return s&&(r-=1e-5,i+=1e-5),s?l.startsWith("u")?$(t,e,n,[r,i]):D(t,e,n,[r,i]):S(t,e,n,[r,i])}function z(t,e){for(let l=0;l<e.length;l++)e[l]&&isNaN(t[l])&&(e[l]=0,t[l]=0)}function $(t,e,l,n){const[r,i]=n;for(let s=0;s<e.length;s++)if(e[s]){const h=t[s];h<r||h>i?e[s]=0:l[s]=h+.5|0}}function D(t,e,l,n){const[r,i]=n;for(let s=0;s<e.length;s++)if(e[s]){const h=t[s];h<r||h>i?e[s]=0:l[s]=h+(h>0?.5:-.5)|0}}function S(t,e,l,n){const[r,i]=n;for(let s=0;s<e.length;s++)if(e[s]){const h=t[s];h<r||h>i?e[s]=0:l[s]=h}}function H(t,e,l){if(t.depthCount&&t.depthCount>1)return;const{pixels:n,statistics:r,pixelType:i}=t,s=n[0].length,h=t.bandMasks??[],a=t.mask??new Uint8Array(s).fill(255),g=i==="f32"||i==="f64",c=T(i);let u=!1;for(let o=0;o<n.length;o++){const f=typeof e=="number"?e:e[o];if(f==null)continue;const p=r?.[o]?.minValue??c[0],w=r?.[o]?.maxValue??c[1];if(p>f+Number.EPSILON||w<f-Number.EPSILON)continue;const v=h[o]||a.slice(),k=n[o],U=l?.customFloatTolerance;if(g&&U!==0){let y=U;y||(y=Math.abs(f)>=R?F*Math.abs(f):i==="f32"?2**-23:Number.EPSILON);for(let B=0;B<k.length;B++)v[B]&&Math.abs(k[B]-f)<y&&(k[B]=0,v[B]=0,a[B]=0,u=!0)}else for(let y=0;y<k.length;y++)v[y]&&k[y]===f&&(k[y]=0,v[y]=0,a[y]=0,u=!0);h[o]=v}if(u){const o=t.bandMasks||t.pixels.length>1?h:null;l?.matchAllNoData?t.mask=o&&o.length>1?x(o):a:(t.bandMasks=o,t.mask=a)}function x(o){if(o.length<2)return o[0];const f=o[0].length,p=new Uint8Array(f).fill(0);for(let w=0;w<o.length;w++){const v=o[w];for(let k=0;k<f;k++)v[k]&&(p[k]=255)}return p}u&&"updateStatistics"in t&&t.updateStatistics()}class V{constructor(e=null,l=null,n=null){this.minValue=e,this.maxValue=l,this.noDataValue=n}}var b;let d=b=class extends C{static createEmptyBand(t,e){return new(b.getPixelArrayConstructor(t))(e)}static combineBandMasks(t){if(t.length<2)return t[0];const e=t[0].length,l=new Uint8Array(e).fill(255);for(let n=0;n<t.length;n++){const r=t[n];for(let i=0;i<e;i++)r[i]||(l[i]=0)}return l}static getPixelArrayConstructor(t){let e;switch(t){case"u1":case"u2":case"u4":case"u8":e=Uint8Array;break;case"u16":e=Uint16Array;break;case"u32":e=Uint32Array;break;case"s8":e=Int8Array;break;case"s16":e=Int16Array;break;case"s32":e=Int32Array;break;case"f32":case"c64":case"c128":case"unknown":e=Float32Array;break;case"f64":e=Float64Array}return e}constructor(t){super(t),this.width=null,this.height=null,this.pixelType="f32",this.validPixelCount=null,this.mask=null,this.maskIsAlpha=!1,this.premultiplyAlpha=!1,this.statistics=null,this.depthCount=1}castPixelType(t){if(!t)return"f32";let e=t.toLowerCase();return["u1","u2","u4"].includes(e)?e="u8":["unknown","u8","s8","u16","s16","u32","s32","f32","f64"].includes(e)||(e="f32"),e}getPlaneCount(){return this.pixels?.length}addData(t){if(!t.pixels||t.pixels.length!==this.width*this.height)throw new N("pixelblock:invalid-or-missing-pixels","add data requires valid pixels array that has same length defined by pixel block width * height");this.pixels||(this.pixels=[]),this.statistics||(this.statistics=[]),this.pixels.push(t.pixels),this.statistics.push(t.statistics??new V)}getAsRGBA(){const t=new ArrayBuffer(this.width*this.height*4);switch(this.pixelType){case"s8":case"s16":case"u16":case"s32":case"u32":case"f32":case"f64":this._fillFromNon8Bit(t);break;default:this._fillFrom8Bit(t)}return new Uint8ClampedArray(t)}getAsRGBAFloat(){const t=new Float32Array(this.width*this.height*4);return this._fillFrom32Bit(t),t}updateStatistics(){if(!this.pixels)return;this.statistics=this.pixels.map(l=>O(l,this.mask));const t=this.mask;let e=0;if(t!=null)for(let l=0;l<t.length;l++)t[l]&&e++;else e=this.width*this.height;this.validPixelCount=e}clamp(t){if(!t||t==="f64"||t==="f32"||!this.pixels)return;const[e,l]=T(t),n=this.pixels,r=this.width*this.height,i=n.length;let s,h,a;const g=[];for(let c=0;c<i;c++){a=b.createEmptyBand(t,r),s=n[c];for(let u=0;u<r;u++)h=s[u],a[u]=h>l?l:h<e?e:h;g.push(a)}this.pixels=g,this.pixelType=t}extractBands(t){const{pixels:e,statistics:l}=this;if(t==null||t.length===0||!e||e.length===0)return this;const n=e.length,r=t.some(u=>u>=e.length),i=n===t.length&&!t.some((u,x)=>u!==x);if(r||i)return this;const s=this.bandMasks?.length===n?t.map(u=>this.bandMasks[u]):void 0;let{mask:h,validPixelCount:a}=this;const{width:g,height:c}=this;return s?.length&&(h=b.combineBandMasks(s),a=h.filter(u=>!!u).length),new b({pixelType:this.pixelType,width:g,height:c,mask:h,bandMasks:s,validPixelCount:a,maskIsAlpha:this.maskIsAlpha,pixels:t.map(u=>e[u]),statistics:l&&t.map(u=>l[u])})}clone(){const t=new b({width:this.width,height:this.height,pixelType:this.pixelType,maskIsAlpha:this.maskIsAlpha,validPixelCount:this.validPixelCount,premultiplyAlpha:this.premultiplyAlpha,depthCount:this.depthCount});let e;this.mask!=null&&(t.mask=new Uint8Array(this.mask)),this.noDataValues&&(t.noDataValues=[...this.noDataValues]),this.bandMasks&&(t.bandMasks=this.bandMasks.map(n=>new Uint8Array(n)));const l=b.getPixelArrayConstructor(this.pixelType);if(this.pixels&&this.pixels.length>0){t.pixels=[];const n=!!this.pixels[0].slice;for(e=0;e<this.pixels.length;e++)t.pixels[e]=n?this.pixels[e].slice():new l(this.pixels[e])}if(this.statistics)for(t.statistics=[],e=0;e<this.statistics.length;e++)t.statistics[e]=P(this.statistics[e]);return t}getTransferableObject(){const{pixels:t,bandMasks:e,mask:l}=this;this.pixels=[],this.bandMasks=void 0,this.mask=void 0;const n=this.toJSON();this.pixels=t,this.bandMasks=e,this.mask=l,n.pixels=t&&[...t],n.bandMasks=e&&[...e],n.mask=l;const r=[];return[...t??[],l,...e??[]].filter(i=>i!=null&&ArrayBuffer.isView(i)).forEach(i=>{i&&!r.includes(i.buffer)&&r.push(i.buffer)}),{pixelBlock:n,transferList:r}}_fillFrom8Bit(t){const{mask:e,maskIsAlpha:l,premultiplyAlpha:n,pixels:r}=this;if(!t||!r?.length)return void M.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");let i,s,h,a;i=s=h=r[0],r.length>=3?(s=r[1],h=r[2]):r.length===2&&(s=r[1]);const g=new Uint32Array(t),c=this.width*this.height;if(i.length===c)if(e!=null&&e.length===c)if(l)for(a=0;a<c;a++){const u=e[a];if(u){const x=u/255;g[a]=n?u<<24|h[a]*x<<16|s[a]*x<<8|i[a]*x:u<<24|h[a]<<16|s[a]<<8|i[a]}}else for(a=0;a<c;a++)e[a]&&(g[a]=255<<24|h[a]<<16|s[a]<<8|i[a]);else for(a=0;a<c;a++)g[a]=255<<24|h[a]<<16|s[a]<<8|i[a];else M.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.")}_fillFromNon8Bit(t){const{pixels:e,mask:l,statistics:n}=this;if(!t||!e?.length)return void M.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");const r=this.pixelType;let i=1,s=0,h=1;if(n&&n.length>0){for(const p of n)if(p.minValue!=null&&(s=Math.min(s,p.minValue)),p.maxValue!=null&&p.minValue!=null){const w=p.maxValue-p.minValue;h=Math.max(h,w)}i=255/h}else{let p=255;r==="s8"?(s=-128,p=127):r==="u16"?p=65535:r==="s16"?(s=-32768,p=32767):r==="u32"?p=4294967295:r==="s32"?(s=-2147483648,p=2147483647):r==="f32"?(s=-34e38,p=34e38):r==="f64"&&(s=-Number.MAX_VALUE,p=Number.MAX_VALUE),i=255/(p-s)}const a=new Uint32Array(t),g=this.width*this.height;let c,u,x,o,f;if(c=u=x=e[0],c.length!==g)return M.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.");if(e.length>=2)if(u=e[1],e.length>=3&&(x=e[2]),l!=null&&l.length===g)for(o=0;o<g;o++)l[o]&&(a[o]=255<<24|(x[o]-s)*i<<16|(u[o]-s)*i<<8|(c[o]-s)*i);else for(o=0;o<g;o++)a[o]=255<<24|(x[o]-s)*i<<16|(u[o]-s)*i<<8|(c[o]-s)*i;else if(l!=null&&l.length===g)for(o=0;o<g;o++)f=(c[o]-s)*i,l[o]&&(a[o]=255<<24|f<<16|f<<8|f);else for(o=0;o<g;o++)f=(c[o]-s)*i,a[o]=255<<24|f<<16|f<<8|f}_fillFrom32Bit(t){const{pixels:e,mask:l}=this;if(!t||!e?.length)return M.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The input pixel block is empty.");let n,r,i,s;n=r=i=e[0],e.length>=3?(r=e[1],i=e[2]):e.length===2&&(r=e[1]);const h=this.width*this.height;if(n.length!==h)return M.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The pixelblock is invalid.");let a=0;if(l!=null&&l.length===h)for(s=0;s<h;s++)t[a++]=n[s],t[a++]=r[s],t[a++]=i[s],t[a++]=1&l[s];else for(s=0;s<h;s++)t[a++]=n[s],t[a++]=r[s],t[a++]=i[s],t[a++]=1}};function O(t,e){let l=1/0,n=-1/0;const r=t.length;let i,s=0;if(e!=null)for(i=0;i<r;i++)e[i]&&(s=t[i],l=s<l?s:l,n=s>n?s:n);else for(i=0;i<r;i++)s=t[i],l=s<l?s:l,n=s>n?s:n;return new V(l,n)}m([A({json:{write:!0}})],d.prototype,"width",void 0),m([A({json:{write:!0}})],d.prototype,"height",void 0),m([A({json:{write:!0}})],d.prototype,"pixelType",void 0),m([L("pixelType")],d.prototype,"castPixelType",null),m([A({json:{write:!0}})],d.prototype,"validPixelCount",void 0),m([A({json:{write:!0}})],d.prototype,"mask",void 0),m([A({json:{write:!0}})],d.prototype,"maskIsAlpha",void 0),m([A({json:{write:!0}})],d.prototype,"pixels",void 0),m([A()],d.prototype,"premultiplyAlpha",void 0),m([A({json:{write:!0}})],d.prototype,"statistics",void 0),m([A({json:{write:!0}})],d.prototype,"depthCount",void 0),m([A({json:{write:!0}})],d.prototype,"noDataValues",void 0),m([A({json:{write:!0}})],d.prototype,"bandMasks",void 0),d=b=m([G("esri.layers.support.PixelBlock")],d);export{q as a,W as b,d as c,z as f,H as g,J as i,V as l,E as r,T as u};
//# sourceMappingURL=PixelBlock-xOAL5nDX.js.map
