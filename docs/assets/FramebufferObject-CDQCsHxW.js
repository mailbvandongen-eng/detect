import{ir as C,U as p,a2 as U,is as a,dE as d,dD as T,it as E,a5 as F,iu as y,iv as R,iw as N,ix as b,iy as A,Z as B}from"./index-C3JOhYFY.js";import{o as M}from"./BufferObject-CxEQZpTW.js";class G{constructor(t,i=0,e=i,r=!1,n=1){this.internalFormat=t,this.width=i,this.height=e,this.multisampled=r,this.samples=n}}function z(s){return s.width<=0||s.height<=0||s.internalFormat==null?0:s.width*s.height*C(s.internalFormat)}const P=!!U("esri-tests-disable-gpu-memory-measurements");class w{constructor(t,i){this._context=t,this._descriptor=i,this.type=2,this._context.instanceCounter.increment(p.Renderbuffer,this);const e=this._context.gl;this.glName=e.createRenderbuffer(),this._context.bindRenderbuffer(this);const{width:r,height:n,internalFormat:h,multisampled:o}=i;o?e.renderbufferStorageMultisample(e.RENDERBUFFER,this.samples,h,r,n):e.renderbufferStorage(e.RENDERBUFFER,h,r,n),this._context.bindRenderbuffer(null)}get descriptor(){return this._descriptor}get samples(){const t=this._descriptor.samples,i=this._context.parameters.maxSamples;return t?Math.min(t,i):i}get usedMemory(){return P?0:z(this._descriptor)}resize(t,i){const e=this._descriptor;if(e.width===t&&e.height===i)return;e.width=t,e.height=i;const r=this._context.gl;this._context.bindRenderbuffer(this),e.multisampled?r.renderbufferStorageMultisample(r.RENDERBUFFER,this.samples,e.internalFormat,e.width,e.height):r.renderbufferStorage(r.RENDERBUFFER,e.internalFormat,e.width,e.height),this._context.bindRenderbuffer(null)}dispose(){this._context&&(this._context.gl.deleteRenderbuffer(this.glName),this._context.instanceCounter.decrement(p.Renderbuffer,this),this._context=null)}}const v=()=>B.getLogger("esri.views.webgl.FramebufferObject");var c;let j=(c=class{constructor(t,i,e){if(this._context=t,this._glName=null,this._colorAttachments=new Map,this._depthStencilBuffer=null,this._depthStencilTexture=null,this._initialized=!1,t.instanceCounter.increment(p.FramebufferObject,this),i!=null){const r=H(t,i);r!=null&&(this._colorAttachments.set(a,r),l(r)?this._validateTextureDescriptor(r.descriptor):this._validateRenderbufferDescriptor(r.descriptor)),this._validateColorAttachmentPoint(a)}if(e!=null)if(L(e))this._depthStencilTexture=l(e)?e:new d(t,e),this._validateTextureDescriptor(this._depthStencilTexture.descriptor);else{const r=S(e)?e:new w(t,e);this._depthStencilBuffer=r,this._validateRenderbufferDescriptor(r.descriptor)}}dispose(){const{_colorAttachments:t,_glName:i}=this;if(t.size===0&&!this._depthStencilBuffer&&!this._depthStencilTexture&&!i)return;const{_context:e}=this,r=e.getBoundFramebufferObject();t.forEach((n,h)=>this.detachColorTexture(h)?.dispose()),this.detachDepthStencilBuffer()?.dispose(),this.detachDepthStencilTexture()?.dispose(),e.gl.deleteFramebuffer(i),this._glName=null,e.bindFramebuffer(r===this?null:r),e.instanceCounter.decrement(p.FramebufferObject,this)}get glName(){return this._glName}get colorTexture(){const t=this._colorAttachments.get(a);return l(t)?t:null}get depthStencil(){return this._depthStencilTexture||this._depthStencilBuffer}get depthStencilTexture(){return this._depthStencilTexture}get width(){return(this._colorAttachments.get(a)??this._depthStencilTexture??this._depthStencilBuffer)?.descriptor?.width??0}get height(){return(this._colorAttachments.get(a)??this._depthStencilTexture??this._depthStencilBuffer)?.descriptor?.height??0}get usedMemory(){return[...this._colorAttachments].reduce((t,[i,e])=>t+e.usedMemory,this.depthStencil?.usedMemory??0)}getColorTexture(t){const i=this._colorAttachments.get(t);return i&&l(i)?i:null}get colorAttachments(){return[...this._colorAttachments.keys()]}attachColorTexture(t,i=a){if(!t)return;this._validateColorAttachmentPoint(i);const{descriptor:e}=t;this._validateTextureDescriptor(e),this.detachColorTexture(i)?.dispose(),this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(t.glName,i)),this._colorAttachments.set(i,t)}detachColorTexture(t=a){const i=this._colorAttachments.get(t);if(!i)return;const e=l(i);return this._initialized&&this._context.temporaryBindFramebufferObject(this,()=>{if(e)this._framebufferTexture2D(null,t);else{const r=this._context.gl;r.framebufferRenderbuffer(r.FRAMEBUFFER,t,r.RENDERBUFFER,null)}}),this._colorAttachments.delete(t),e?i:void 0}setColorTextureTarget(t,i=a,e=0){const r=this._colorAttachments.get(i);r&&(t===35866?this._framebufferTextureLayer(r.glName,i,36160,0,e):this._framebufferTexture2D(r.glName,i,t,36160,0))}attachDepthStencil(t){if(t)switch(t.type){case 1:return this._attachDepthStencilTexture(t);case 2:return this._attachDepthStencilBuffer(t)}}_attachDepthStencilTexture(t){if(t==null)return;const{descriptor:i}=t,{pixelFormat:e,dataType:r}=i;e===34041||e===6402?e!==34041||r===T.UNSIGNED_INT_24_8?e!==6402||r===T.UNSIGNED_INT||r===T.UNSIGNED_SHORT?(this._validateTextureDescriptor(i),this._disposeDepthStencilAttachments(),this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(t.glName,m(e))),this._depthStencilTexture?.dispose(),this._depthStencilTexture=t):console.error("Depth texture must have data type of UNSIGNED_INT or UNSIGNED_SHORT!"):console.error("Depth/Stencil texture must have data type of UNSIGNED_INT_24_8!"):console.error("Depth/Stencil texture must have a pixel type of DEPTH_STENCIL!")}detachDepthStencilTexture(){const t=this._depthStencilTexture;return t&&this._initialized&&this._context.temporaryBindFramebufferObject(this,()=>{this._framebufferTexture2D(null,m(t.descriptor.pixelFormat))}),this._depthStencilTexture=null,t}_attachDepthStencilBuffer(t){if(t==null)return;const i=t.descriptor;if(this._validateRenderbufferDescriptor(i),this._disposeDepthStencilAttachments(),this._initialized){this._context.bindFramebuffer(this);const{gl:e}=this._context,r=this._getGLAttachmentPoint(i);e.framebufferRenderbuffer(36160,r,e.RENDERBUFFER,t.glName)}this._depthStencilBuffer=t}detachDepthStencilBuffer(){const t=this._depthStencilBuffer;if(t&&this._initialized){const{_context:i}=this,e=i.getBoundFramebufferObject();i.bindFramebuffer(this);const{gl:r}=i,n=this._getGLAttachmentPoint(t.descriptor);r.framebufferRenderbuffer(36160,n,r.RENDERBUFFER,null),i.bindFramebuffer(e)}return this._depthStencilBuffer=null,t}invalidateAttachments(t){const{_context:i}=this;i.temporaryBindFramebufferObject(this,()=>i.gl.invalidateFramebuffer(36160,t),!0)}copyToTexture(t,i,e,r,n,h,o){(t<0||i<0||n<0||h<0)&&console.error("Offsets cannot be negative!"),(e<=0||r<=0)&&console.error("Copy width and height must be greater than zero!");const f=o.descriptor;o.descriptor.target!==3553&&console.error("Texture target must be TEXTURE_2D!"),(f?.width==null||f?.height==null||t+e>this.width||i+r>this.height||n+e>f.width||h+r>f.height)&&console.error("Bad dimensions, the current input values will attempt to read or copy out of bounds!");const u=this._context,g=u.bindTexture(o,d.TEXTURE_UNIT_FOR_UPDATES);u.setActiveTexture(d.TEXTURE_UNIT_FOR_UPDATES),u.bindFramebuffer(this),u.gl.copyTexSubImage2D(3553,0,n,h,t,i,e,r),u.bindTexture(g,d.TEXTURE_UNIT_FOR_UPDATES)}readPixels(t,i,e,r,n,h,o){(e<=0||r<=0)&&console.error("Copy width and height must be greater than zero!"),o||console.error("Target memory is not initialized!"),this._context.bindFramebuffer(this),this._context.gl.readPixels(t,i,e,r,n,h,o)}async readPixelsAsync(t,i,e,r,n,h,o){const{gl:f}=this._context,u=M.createPixelPack(this._context,35041,o.byteLength);this._context.bindBuffer(u);const g=this._context.getBoundFramebufferObject();this._context.bindFramebuffer(this),f.readPixels(t,i,e,r,n,h,0),this._context.unbindBuffer(35051),this._context.bindFramebuffer(g),await u.getSubDataAsync(o),u.dispose()}resize(t,i){if(this.width===t&&this.height===i)return;const e={width:t,height:i};if(_(e,this._context.parameters.maxTextureSize),this._colorAttachments.forEach(r=>r.resize(e.width,e.height)),this._depthStencilTexture?.resize(e.width,e.height),this._initialized&&(_(e,this._context.parameters.maxRenderbufferSize),this._depthStencilBuffer?.resize(e.width,e.height),E())){const{gl:r}=this._context;r.checkFramebufferStatus(36160)!==r.FRAMEBUFFER_COMPLETE&&console.error("Framebuffer is incomplete!")}}initializeAndBind(t=36160){const{gl:i}=this._context;if(this._initialized)return void i.bindFramebuffer(t,this.glName);this._glName&&i.deleteFramebuffer(this._glName);const e=i.createFramebuffer();if(i.bindFramebuffer(t,e),this._colorAttachments.forEach((r,n)=>{if(l(r)){const h=D(r);h===35866?this._framebufferTextureLayer(r.glName,n,t,0,0):this._framebufferTexture2D(r.glName,n,h,t)}else if(S(r)){const h=this._context.gl;h.framebufferRenderbuffer(t,n,h.RENDERBUFFER,r.glName)}}),this._depthStencilBuffer){const r=this._getGLAttachmentPoint(this._depthStencilBuffer.descriptor);i.framebufferRenderbuffer(t,r,i.RENDERBUFFER,this._depthStencilBuffer.glName)}else if(this._depthStencilTexture){const r=m(this._depthStencilTexture.descriptor.pixelFormat);this._framebufferTexture2D(this._depthStencilTexture.glName,r,D(this._depthStencilTexture),t)}E()&&i.checkFramebufferStatus(t)!==i.FRAMEBUFFER_COMPLETE&&console.error("Framebuffer is incomplete!"),this._glName=e,this._initialized=!0}_framebufferTexture2D(t,i=a,e=3553,r=36160,n=0){this._context.gl.framebufferTexture2D(r,i,e,t,n)}_framebufferTextureLayer(t,i=a,e=36160,r=0,n=0){this._context.gl.framebufferTextureLayer(e,i,t,r,n)}_disposeDepthStencilAttachments(){const t=this._context.gl;if(this._depthStencilBuffer){if(this._initialized){this._context.bindFramebuffer(this);const i=this._getGLAttachmentPoint(this._depthStencilBuffer.descriptor);t.framebufferRenderbuffer(36160,i,t.RENDERBUFFER,null)}this._depthStencilBuffer=F(this._depthStencilBuffer)}this._depthStencilTexture&&(this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(null,m(this._depthStencilTexture.descriptor.pixelFormat))),this._depthStencilTexture=F(this._depthStencilTexture))}_validateTextureDescriptor(t){t.target!==3553&&t.target!==34067&&t.target!==35866&&console.error("Texture type must be TEXTURE_2D, TEXTURE_2D_ARRAY or TEXTURE_CUBE_MAP!"),_(t,this._context.parameters.maxTextureSize),this._validateBufferDimensions(t)}_validateRenderbufferDescriptor(t){_(t,this._context.parameters.maxRenderbufferSize),this._validateBufferDimensions(t)}_validateBufferDimensions(t){t.width<=0&&(t.width=this.width),t.height<=0&&(t.height=this.height),this.width>0&&this.height>0&&(this.width===t.width&&this.height===t.height||console.error("Attachment size must match framebuffer size!"))}_getGLAttachmentPoint(t){switch(t.internalFormat){case b.DEPTH_COMPONENT16:case b.DEPTH_COMPONENT24:case b.DEPTH_COMPONENT32F:return A;case R.DEPTH24_STENCIL8:case R.DEPTH32F_STENCIL8:return N;case 36168:return y;default:return a}}_validateColorAttachmentPoint(t){if(c._MAX_COLOR_ATTACHMENTS===-1){const{gl:e}=this._context;c._MAX_COLOR_ATTACHMENTS=e.getParameter(e.MAX_COLOR_ATTACHMENTS)}const i=t-a;i+1>c._MAX_COLOR_ATTACHMENTS&&B.getLogger("esri.views.webgl.FrameBufferObject").error("esri.FrameBufferObject",`illegal attachment point for color attachment: ${i+1}. Implementation supports up to ${c._MAX_COLOR_ATTACHMENTS} color attachments`)}},c._MAX_COLOR_ATTACHMENTS=-1,c);function l(s){return x(s)===1}function S(s){return x(s)===2}function L(s){return l(s)||O(s)}function O(s){return x(s)===0}function I(s){return x(s)===3||s!=null&&"samples"in s}function x(s){return s!=null&&"type"in s?s.type:null}function H(s,t){return l(t)||S(t)?t:O(t)?new d(s,t):I(t)?new w(s,t):null}function _(s,t){const i=Math.max(s.width,s.height);if(i>t){v().warnOnce(`Resizing FBO attachment size ${s.width}x${s.height} to device limit ${t}`);const e=t/i;return s.width=Math.round(s.width*e),s.height=Math.round(s.height*e),!1}return!0}function D(s){return s.descriptor.target===34067?34069:s.descriptor.target===35866?35866:3553}function m(s){return s===6402?A:N}export{G as i,j as m,w as s};
//# sourceMappingURL=FramebufferObject-CDQCsHxW.js.map
